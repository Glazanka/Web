Какво трябва да има във вашия бекенд, за да отговаря на фронтенда:

Reminder модел:

java
Copy
Edit
@Document(collection = "reminders")
public class Reminder {
    @Id
    private String id;
    private String noteId;
    private String ownerId;
    private Date remindAt;
    private boolean sent;
    // + гетъри/сеттер‐и
}
ReminderRepository:

java
Copy
Edit
public interface ReminderRepository extends MongoRepository<Reminder, String> {
    List<Reminder> findByOwnerIdAndSentFalseAndRemindAtAfter(String ownerId, Date now);
}
(или findByOwnerIdAndSentFalseAndRemindAtBefore ако обаче логиката е да върнете тези „≤ now“; важното е да върнете всички ненаправени („sent = false“) напомняния, чието remindAt е в миналото или бъдещето, в зависимост от нуждата на фронтенда.)

ReminderService:

java
Copy
Edit
public class ReminderService {
    private final ReminderRepository repo;
    private final NoteRepository noteRepo; // за да взимате noteTitle ако е нужно

    public Reminder createReminder(String noteId, Date remindAt, String userId) {
        // Проверка: noteRepo.findById(noteId) -> валидно ли е и ownerId ли е
        Reminder r = new Reminder();
        r.setNoteId(noteId);
        r.setRemindAt(remindAt);
        r.setOwnerId(userId);
        r.setSent(false);
        return repo.save(r);
    }

    public List<ReminderDTO> getUpcoming(String userId) {
        Date now = new Date();
        List<Reminder> list = repo.findByOwnerIdAndSentFalseAndRemindAtAfter(userId, now);
        // Ако искате noteTitle, направете втори lookup в noteRepo и върнете DTO с noteTitle
    }

    public void deleteReminder(String id, String userId) {
        Reminder r = repo.findById(id).orElseThrow(...);
        if (!r.getOwnerId().equals(userId)) throw new RuntimeException("Нямате достъп");
        repo.deleteById(id);
    }

    public void markSent(String id, String userId) {
        Reminder r = repo.findById(id).orElseThrow(...);
        if (!r.getOwnerId().equals(userId)) throw new RuntimeException("Нямате достъп");
        r.setSent(true);
        repo.save(r);
    }
}
ReminderController:

java
Copy
Edit
@RestController
@RequestMapping("/api/reminders")
public class ReminderController {
    private final ReminderService service;

    @PostMapping("")
    public ResponseEntity<ReminderDTO> createReminder(
        @AuthenticationPrincipal(expression="username") String userId,
        @RequestBody CreateReminderRequest body) {
        Reminder r = service.createReminder(body.getNoteId(), Date.from(Instant.parse(body.getRemindAt())), userId);
        // Върнете някакъв DTO (може да включва noteTitle след lookup)
        return ResponseEntity.status(201).body(...);
    }

    @GetMapping("/upcoming")
    public ResponseEntity<List<ReminderDTO>> getUpcoming(@AuthenticationPrincipal(expression="username") String userId) {
        List<ReminderDTO> list = service.getUpcoming(userId);
        return ResponseEntity.ok(list);
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteReminder(
        @PathVariable String id,
        @AuthenticationPrincipal(expression="username") String userId) {
        service.deleteReminder(id, userId);
        return ResponseEntity.noContent().build();
    }

    @PutMapping("/{id}/markSent")
    public ResponseEntity<Void> markSent(
        @PathVariable String id,
        @AuthenticationPrincipal(expression="username") String userId) {
        service.markSent(id, userId);
        return ResponseEntity.ok().build();
    }
}
Auth / CORS / SecurityConfig
За да може @AuthenticationPrincipal да „вади“ текущия userId от JWT, трябва да сте настроили:

CorsConfigurationSource, който позволява http://localhost:3000.

PasswordEncoder (BCrypt) и регистрационен/login филтър, които генерират JWT.

JWTAuthorizationFilter, който прочита header Authorization: Bearer {token}, вади userId и го слага в SecurityContext.

Security конфигурация, която:

java
Copy
Edit
http
  .csrf().disable()
  .cors().and()
  .authorizeRequests()
    .antMatchers("/api/auth/**", "/public/**").permitAll()
    .anyRequest().authenticated()
  .and()
  .addFilterBefore(jwtAuthorizationFilter, UsernamePasswordAuthenticationFilter.class);